# Server Architecture - HTTP and Socket Separation

This project now uses a clean separation between HTTP and WebSocket logic through dedicated services.

## Architecture Overview

```
index.ts (entry point)
    â†“
ServerManager
    â”œâ”€â”€ HTTPService (Express.js routes & middleware)
    â””â”€â”€ SocketService (Socket.IO connections & events)
```

## Services

### 1. ServerManager (`src/services/server.service.ts`)

- **Purpose**: Orchestrates the entire server startup process
- **Responsibilities**:
  - Creates and configures HTTP and Socket services
  - Manages server lifecycle (start, stop)
  - Handles database setup
  - Initializes logging

### 2. HTTPService (`src/services/http.service.ts`)

- **Purpose**: Handles all HTTP-related functionality
- **Responsibilities**:
  - Express.js app configuration
  - CORS setup
  - Route management (health check, tRPC)
  - Middleware configuration
  - Error handling

### 3. SocketService (`src/services/socket.service.ts`)

- **Purpose**: Manages all WebSocket connections and events
- **Responsibilities**:
  - Socket.IO server configuration
  - Connection/disconnection handling
  - Custom event management
  - Broadcasting capabilities
  - Connection pooling

## Optional: Custom Socket Handlers

### SocketEventHandlers (`src/socket/socket-handlers.ts`)

- **Purpose**: Demonstrates how to organize custom socket events
- **Features**:
  - Chat functionality (join/leave rooms, send messages)
  - Notification subscriptions
  - Real-time data updates
  - Modular handler organization

## Usage Examples

### Starting the Server

```typescript
// Simple startup (current implementation)
const serverManager = new ServerManager();
serverManager.start(4000);
```

### Adding Custom HTTP Routes

```typescript
const serverManager = new ServerManager();
const httpService = serverManager.getHTTPService();
httpService.addRoute("/api/custom", customRouter);
```

### Broadcasting Socket Messages

```typescript
const serverManager = new ServerManager();
const socketService = serverManager.getSocketService();

// Broadcast to all clients
socketService.broadcastToAll("update", { message: "Server update" });

// Broadcast to specific room
socketService.broadcastToRoom("room1", "notification", { text: "New message" });
```

### Using Custom Socket Handlers

1. Uncomment the import in `socket.service.ts`:

   ```typescript
   import { SocketEventHandlers } from "../socket/socket-handlers";
   ```

2. Enable handlers in the `registerCustomEventHandlers` method:
   ```typescript
   SocketEventHandlers.registerChatHandlers(socket);
   SocketEventHandlers.registerNotificationHandlers(socket);
   SocketEventHandlers.registerDataHandlers(socket);
   ```

## Benefits

### ðŸ”’ **Separation of Concerns**

- HTTP logic is completely separated from WebSocket logic
- Each service has a single, clear responsibility
- Easy to maintain and debug

### ðŸ§ª **Testability**

- Services can be unit tested independently
- Mock dependencies easily
- Test HTTP routes without WebSocket complexity

### ðŸ“ˆ **Scalability**

- Easy to add new HTTP routes or Socket events
- Services can be extracted to microservices later
- Clear extension points for new functionality

### ðŸ”§ **Maintainability**

- Changes to HTTP logic don't affect WebSocket logic
- Clear code organization
- Easy onboarding for new developers

### ðŸŽ¯ **Type Safety**

- Full TypeScript support
- Clear interfaces and method signatures
- Compile-time error checking

## Migration Notes

This refactor maintains 100% backward compatibility:

- All existing HTTP routes work unchanged
- Socket.IO functionality is identical
- Logger integration remains the same
- No breaking changes to the API

## Next Steps

Consider implementing:

1. **Environment-specific configurations**
2. **Health check endpoints for services**
3. **Graceful shutdown handling**
4. **Metrics and monitoring**
5. **Rate limiting for socket events**
